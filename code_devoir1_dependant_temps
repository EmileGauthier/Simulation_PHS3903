import time
import numpy as np
import matplotlib.pyplot as plt
import scipy.sparse as sp
import bisect
from matplotlib.ticker import AutoMinorLocator

# Paramètres du problème
L = 2 #[m] ; Épaisseur du mur
k = 1 #[W/(m*K)]; La conductivité thermique de la brique
h = 10 #[W/(m^2*K)]; Coefficient de transfert thermique pour l'interface plane entre l'air et solide.
Cv = 1000 # [J/(kg*K)] ; Capacité thermique volumique
rho = 2000 # [kg/m^3] ; Masse volumique
alpha = (Cv*rho)/k
xi = 0.75 # Paramètre déterminant la méthode numérique (0: explicite, 1: implicite, 0.5: Crank-Nicolson)

# Condition convective (de Robin) à x=0 (face externe du mur): -k*dT/dx=h(Ta-T)
Ta = -15; #[oC]
c1 = -k; c2 = h; c3 = -h*Ta
# Condition convective (de Robin) à x=L (face interne du mur): -k*dT/dx=h(T-Ta)
d1 = -k; d2 = -h; d3 = h*Ta

Nar = np.array([200]) # Nombre de noeuds du domaine

ci = -1; # Indice qui augmente à chaque itération de la boucle sur N
Tmax_eq = np.zeros(Nar.size,dtype=np.double) # Température maximale à l'équilibre

for N in Nar:

    print('Nombre de points sur la grille =',N)
    ci = ci+1 # Compteur. Commence à 0.

    S = np.zeros(N+1,dtype=np.double) # Valeur de la source à chacun des points du maillage
    A = np.zeros((N+1,N+1),dtype=np.double) # Matrice A dans la forme matricielle du problème
    b = np.zeros(N+1,dtype=np.double) # Vecteur b dans la forme matricielle du problème
    
    dx = L/N; # Pas de discrétisation (espace)
    x = np.linspace(0,L,N+1) # Position des points du maillage
    dt = alpha * dx**2 # Pas de discrétisation (temps)
    t_final = 1e7 # Durée de simulation (s)
    t_array = np.arange(0,t_final,dt) 

    u_n = Ta * np.ones(N+1,dtype=np.double) # Condition initiale

    # Calcul de la source à chaque point du maillage (ici indépendant de t)
    dL = 0.5 # m
    q = 400 # W/m^3;
    S = q*np.exp(-x/dL)

    e = np.ones(N+1)

    # Matrice A (indépendante de t)
    A = sp.diags(
        diagonals=[e[:-1], -2*e, e[:-1]],
        offsets=[-1, 0, 1],
        shape=(N+1, N+1),
        format="lil"
    )

    # Conditions aux bords
    A[0, 0] = 2*c2*dx - 3*c1; A[0, 1] = 4*c1; A[0, 2] = -c1
    A[N, N]     = 3*d1 + 2*d2*dx; A[N, N-1]   = -4*d1; A[N, N-2]   = d1

    # Identité
    M = sp.eye(N+1, format="lil")

    # Conditions aux bords
    M[0, 0] = 0
    M[N, N] = 0

    # Vecteur b (indépendant de t)
    b = - S/k*dx**2; 
    b[0] = -2*c3*dx; 
    b[N] = -2*d3*dx

    # A_prime pour la résolution dépendente du temps (indépendante de t)
    A_prime = sp.csr_matrix(M - dt*xi/(alpha*dx**2)*A)

    i = 0 # Indice qui augmente à chaque itération de la boucle sur N
    Tmax_t = np.zeros(t_array.size, dtype=np.double)

    for t in t_array:
        
        b_prime = (M + dt*(1 - xi)/(alpha*dx**2)*A) @ u_n - dt/(alpha*dx**2)*b

        u_nplus1 = sp.linalg.spsolve(A_prime, b_prime)

        Tmax_t[i] = u_n.max()

        u_n = u_nplus1.copy()

        i = i + 1
    
    Tmax_eq[ci] = u_n.max()

# Identification du temps d'équilibrage du système
tau_eq_indice = bisect.bisect(Tmax_t, Ta + 0.95*(Tmax_eq.max() - Ta))
tau_eq = t_array[tau_eq_indice]
print("Température maximale au temps d'équilibrage :", Tmax_t[tau_eq_indice], "\u00b0C.")
print("Température maximale à l'équilibre :",Tmax_eq, "\u00b0C.")
print("Temps d'équilibrage : ", tau_eq, "secondes.")

# Graphique question ii)
fig,ax = plt.subplots()
plt.plot(t_array,Tmax_t, color = 'red')
plt.hlines(y= Ta + 0.95*(Tmax_eq.max() - Ta), xmin=-0.03e7, xmax=1e7, color='blue', linestyle='--')
plt.xlabel(f"t [s]")
plt.ylabel("$T_{max}$(t) [\u00b0C]")
ax.tick_params(axis='x', which='both',direction="in", top=True, labeltop=False)
ax.tick_params(axis='y', which='both',direction="in", right=True, labelright=False)
ax.minorticks_on() 
ax.tick_params(which='minor', length=4, color='gray')
ax.xaxis.set_minor_locator(AutoMinorLocator(4))
ax.yaxis.set_minor_locator(AutoMinorLocator(4))
ax.grid(which='major', color='#CCCCCC', linestyle='-', linewidth=0.8)
ax.grid(which='minor', color='#DDDDDD', linestyle=':', linewidth=0.5) 
plt.xlim(-0.03e7,1e7)
plt.show()
