import time
import numpy as np
import matplotlib.pyplot as plt
from scipy import sparse
import bisect

# Paramètres du problème
L = 2 #[m] ; Épaisseur du mur
k = 0.5 #[W/(m*K)]; La conductivité thermique de la brique
h = 20 #[W/(m^2*K)]; Coefficient de transfert thermique pour l'interface plane entre l'air et solide.
Cv = 1000 # [J/(kg*K)] ; Capacité thermique volumique
rho = 2000 # [kg/m^3] ; Masse volumique
alpha = (Cv*rho)/k
xi = 0.5 # Paramètre déterminant la méthode numérique (0: explicite, 1: implicite, 0.5: Crank-Nicolson)

# Condition convective (de Robin) à x=0 (face externe du mur): -k*dT/dx=h(Ta-T)
Ta = -15; #[oC]
c1 = -k; c2 = h; c3 = -h*Ta
# Condition convective (de Robin) à x=L (face interne du mur): -k*dT/dx=h(T-Ta)
d1 = -k; d2 = -h; d3 = h*Ta


Nar = np.array([200]) # Nombre de noeuds du domaine
#Nar1= np.concatenate((np.arange(2, 11, 1), np.arange(20, 110, 10), np.arange(200, 1100, 100), np.arange(2000, 6000, 1000))); # Matrice pleine
 
# Pour évaluer l'erreur, on teste avec N et 2*N noeuds
#Nar = np.zeros(2*Nar1.size,dtype=Nar1.dtype)
#Nar[np.arange(0,2*Nar1.size-1,2)] = Nar1.copy()
#Nar[np.arange(0,2*Nar1.size-1,2)+1] = 2*Nar1.copy()

ci = -1; # Indice qui augmente à chaque itération de la boucle sur N
#Err=np.zeros(Nar1.size,dtype=np.double) # Erreur de calcul sur la température maximale à l'équilibre
Tmax_eq = np.zeros(Nar.size,dtype=np.double) # Température maximale à l'équilibre

plt.figure(1)
for N in Nar:

    print('Nombre de points sur la grille =',N)
    ci = ci+1 # Compteur. Commence à 0.

    S = np.zeros(N+1,dtype=np.double) # Valeur de la source à chacun des points du maillage
    A = np.zeros((N+1,N+1),dtype=np.double) # Matrice A dans la forme matricielle du problème
    b = np.zeros(N+1,dtype=np.double) # Vecteur b dans la forme matricielle du problème
    
    dx = L/N; # Pas de discrétisation (espace)
    x = np.linspace(0,L,N+1) # Position des points du maillage
    dt = alpha * dx**2 # Pas de discrétisation (temps)
    t_final = 1e7 # Durée de simulation (s)
    t_array = np.arange(0,t_final,dt) 

    u_n = Ta * np.ones(N+1,dtype=np.double) # Condition initiale

    # Calcul de la source à chaque point du maillage (ici indépendant de t)
    dL = 0.1
    q = 400 # W/m^3;
    S = q*np.exp(-x/dL)

    # Matrice A (indépendante de t)
    A = np.diag(-2*np.ones(N+1),0)+np.diag(np.ones(N),-1)+np.diag(np.ones(N),1)
    A[0,0] = 2*c2*dx-3*c1; A[0,1] = 4*c1;A[0,2]=-c1
    A[N,N] = 3*d1+2*d2*dx; A[N,N-1] = -4*d1;A[N,N-2]=d1

    # Matrice M  (indépendante de t)
    M = np.diag(np.ones(N+1),0)
    M[0,0] = 0; M[N,N] = 0

    # Vecteur b (indépendant de t)
    b = - S/k*dx**2; 
    b[0] = -2*c3*dx; 
    b[N] = -2*d3*dx

    # A_prime pour la résolution dépendente du temps (indépendante de t)
    A_prime = sparse.csr_matrix(M - dt*xi/(alpha*dx**2)*A)

    i = 0 # Indice qui augmente à chaque itération de la boucle sur N
    Tmax_t = np.zeros(t_array.size, dtype=np.double)

    for t in t_array:
        
        b_prime = (M + dt*(1 - xi)/(alpha*dx**2)*A) @ u_n - dt/(alpha*dx**2)*b

        u_nplus1 = sparse.linalg.spsolve(A_prime, b_prime)

        Tmax_t[i] = u_n.max()

        u_n = u_nplus1.copy()

        i = i + 1
    
    Tmax_eq[ci] = u_n.max()
    plt.plot(x,u_n)
    
plt.axis([x[0], x[-1], Ta, Tmax_eq.max()])
plt.title('Température (x)')
plt.xlabel('x [m]')    
plt.ylabel('$T_{eq}$(x) [$^o$C]')
plt.show()

# Identification du temps d'équilibrage du système
tau_eq_indice = bisect.bisect(Tmax_t, Ta + 0.95*(Tmax_eq.max() - Ta))
tau_eq = t_array[tau_eq_indice]
print(tau_eq)

# Graphique question ii)
plt.plot(t_array,Tmax_t, color = 'red')
plt.hlines(y= Ta + 0.95*(Tmax_eq.max() - Ta), xmin=0, xmax=1e7, color='blue', linestyle='--')
plt.show()

#Err=np.abs(Tmax_eq[np.arange(0,Tmax.size,2)]-Tmax_eq[np.arange(1,Tmax_eq.size,2)])
#plt.figure(2)
#plt.plot(L/Nar1,Err,'-or')
#plt.xscale('log')
#plt.yscale('log')
#plt.title('Erreur (N)')
#plt.xlabel('dx [m]')
#plt.ylabel('Err(dx)=|$T_{max}$(dx)-$T_{max}$(dx/2)|')
#plt.show()
