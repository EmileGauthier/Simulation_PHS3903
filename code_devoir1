import time
import numpy as np
import matplotlib.pyplot as plt
from scipy import sparse
# Équation différentielle: d^2 u/dx^2=g(x) sur x=(a,b)
# Conditions aux limites générales:
# x=a: c1*du/dx+c2*u+c3=0
# x=b: d1*du/dx+d2*u+d3=0

# Équation de transfert de chaleur d^2 T/dx^2=-S(x)/k sur x=(0,L)
# dans un mur d'isolation thermique
L=0.3; #[m] ; Épaisseur du mur

k=1;#[W/(m*K)]; La conductivité thermique de la brique
h=1; #[W/(m^2*K)]; Coefficient de transfert thermique pour l'interface plane entre l'air et solide.
Cv = 1e3 # [J/(kg*K)] ; Capacité thermique volumique
rho = 2000 # [kg/m^3] ; Masse volumique
alpha = (Cv*rho)/k

xi=0.6 # Paramètre déterminant la méthode numérique (0: explicite, 1: implicite, 0.5: Crank-Nicolson)

# Condition convective (de Robin) à x=0 (face externe du mur): -k*dT/dx=h(Ta-T)
Ta=-15; #[oC]
c1=-k; c2=h; c3=-h*Ta;
# Condition convective (de Robin) à x=L (face interne du mur): -k*dT/dx=h(T-Ta)
d1=-k; d2=-h; d3=h*Ta;

#(N+1) nœuds dans la maille
# Nmax=10000 pour 1G de mémoire

Nar1=np.array([100]); #dx=3mm
#Nar1= np.concatenate((np.arange(2, 11, 1), np.arange(20, 110, 10), np.arange(200, 1100, 100), np.arange(2000, 6000, 1000))); # Matrice pleine
 
Nar=np.zeros(2*Nar1.size,dtype=Nar1.dtype);
Nar[np.arange(0,2*Nar1.size-1,2)]=Nar1.copy();
Nar[np.arange(0,2*Nar1.size-1,2)+1]=2*Nar1.copy();

ci=-1;
Err=np.zeros(Nar1.size,dtype=np.double);
tInv=np.zeros(Nar.size,dtype=np.double);
Tmax=np.zeros(Nar.size,dtype=np.double);

plt.figure(1)
for N in Nar:

    S=np.zeros(N+1,dtype=np.double);
    A=np.zeros((N+1,N+1),dtype=np.double);
    b=np.zeros(N+1,dtype=np.double);
    u=np.ones(N+1,dtype=np.double);
    u_plus1=np.zeros(N+1,dtype=np.double);
    print('Nombre de points sur la grille=',N);
    ci=ci+1;
    dx=L/N; #Pas de discrétisation
    x=np.linspace(0,L,N+1);
    dt=400; #pas de temps fictif pour la convergence
    t_final = 1e7

    u_n = np.ones(N+1,dtype=np.double)*Ta; # Condition initiale
    t_array = np.arange(0,t_final,dt)

    dL=0.5; 
    q=400; # W/m^3;
    S=q*np.exp(-((x-L)/dL)**2)

    # matrice pleine
    A=np.diag(-2*np.ones(N+1),0)+np.diag(np.ones(N),-1)+np.diag(np.ones(N),1);
    A[0,0]=2*c2*dx-3*c1;A[0,1]=4*c1;A[0,2]=-c1;
    A[N,N]=3*d1+2*d2*dx;A[N,N-1]=-4*d1;A[N,N-2]=d1;
    M=np.diag(np.ones(N+1),0);
    M[0,0]=0; M[N,N]=0;
    b=- S/k*dx**2; 
    b[0]=-2*c3*dx; 
    b[N]=-2*d3*dx;
    A_prime=sparse.csr_matrix(M - dt*xi/(alpha*dx**2)*A);

    for t in t_array:
        # Sourse volumique de chaleur q[W/m^3] d'épaisseur dL
        # La source est intégrée dans la partie intérieure du mur
        
        b_prime = (M + dt*(1 - xi)/(alpha*dx**2)*A) @ u_n - dt/(alpha*dx**2)*b;

        u_nplus1 = sparse.linalg.spsolve(A_prime, b_prime)
        u_n = u_plus1.copy()

    
    tic=time.time_ns();
    u=np.linalg.solve(A, b); # Option préférée
#    u=np.linalg.inv(A)@b; # Option gourmande en mémoire
    toc=time.time_ns();
    tInv[ci]=(toc-tic)/1e9; #temps en [s]   
    
    Tmax[ci]=u.max();
    plt.plot(x,u);
    
plt.axis([x[0], x[-1], Ta, Tmax.max()])
plt.title('Température (x)')
plt.xlabel('x [m]')    
plt.ylabel('$T_{eq}$(x) [$^o$C]')
plt.show()

Err=np.abs(Tmax[np.arange(0,Tmax.size,2)]-Tmax[np.arange(1,Tmax.size,2)]);
plt.figure(2)
plt.plot(L/Nar1,Err,'-or');
plt.xscale('log')
plt.yscale('log')
plt.title('Erreur (N)')
plt.xlabel('dx [m]')
plt.ylabel('Err(dx)=|$T_{max}$(dx)-$T_{max}$(dx/2)|')
plt.show()

plt.figure(3)
plt.loglog(Nar,tInv,'o')
plt.title('Temps de calcul (N)')
plt.xlabel('N')
plt.ylabel('temps [s]')

Tmax_eq=Tmax[-2];
print('N=',Nar1[-1],'Tmax=',Tmax_eq)
